<?xml version="1.0"?>
<doc>
<assembly>
<name>
PFP
</name>
</assembly>
<members>
<member name="T:PFP.My.Resources.Resources">
<summary>
  Eine stark typisierte Ressourcenklasse zum Suchen von lokalisierten Zeichenfolgen usw.
</summary>
</member>
<member name="P:PFP.My.Resources.Resources.ResourceManager">
<summary>
  Gibt die zwischengespeicherte ResourceManager-Instanz zurück, die von dieser Klasse verwendet wird.
</summary>
</member>
<member name="P:PFP.My.Resources.Resources.Culture">
<summary>
  Überschreibt die CurrentUICulture-Eigenschaft des aktuellen Threads für alle
  Ressourcenzuordnungen, die diese stark typisierte Ressourcenklasse verwenden.
</summary>
</member>
<member name="P:PFP.My.Resources.Resources.buyorder">
<summary>
  Sucht eine lokalisierte Ressource vom Typ System.Drawing.Bitmap.
</summary>
</member>
<member name="P:PFP.My.Resources.Resources.createorder">
<summary>
  Sucht eine lokalisierte Ressource vom Typ System.Drawing.Bitmap.
</summary>
</member>
<member name="P:PFP.My.Resources.Resources.logo">
<summary>
  Sucht eine lokalisierte Ressource vom Typ System.Drawing.Icon ähnlich wie (Symbol).
</summary>
</member>
<member name="P:PFP.My.Resources.Resources.OpenOrder">
<summary>
  Sucht eine lokalisierte Ressource vom Typ System.Drawing.Bitmap.
</summary>
</member>
<member name="P:PFP.My.Resources.Resources.responseopenorder">
<summary>
  Sucht eine lokalisierte Ressource vom Typ System.Drawing.Bitmap.
</summary>
</member>
<member name="P:PFP.My.Resources.Resources.settings">
<summary>
  Sucht eine lokalisierte Ressource vom Typ System.Drawing.Bitmap.
</summary>
</member>
<member name="P:PFP.My.Resources.Resources.showmyopenorder">
<summary>
  Sucht eine lokalisierte Ressource vom Typ System.Drawing.Bitmap.
</summary>
</member>
<member name="P:PFP.My.Resources.Resources.symbol">
<summary>
  Sucht eine lokalisierte Ressource vom Typ System.Drawing.Bitmap.
</summary>
</member>
<member name="M:PFP.PFPForm.GetLVColNameFromSubItem(System.Windows.Forms.ListView@,System.String,System.Windows.Forms.ListViewItem,System.Int32)">
 <summary>
 Von einer ListView das subitem aus dem item lesen
 </summary>
 <param name="LV">Die ListView, aus der gelesen werden soll</param>
 <param name="ColName">Der Spaltenname, aus dem gelesen werden soll</param>
 <param name="LVItem">Die Zeile bzw. das item aus dem gelesen werden soll</param>
 <param name="index">Alternativ das item an index stelle in der ListView</param>
 <returns>Vorzugsweise einen String, andernfalls den index der Spalte</returns>
 <remarks></remarks>
</member>
<member name="T:PFP.ListViewItemExtremeSorter">
 <summary>
 Beispiel Standard:
 ListView1.ListViewItemSorter = New ListViewItemExtremeSorter(SortOrder.Ascending, 0, 0, 1, 0, 3, 1)
 </summary>
</member>
<member name="M:PFP.ListViewItemExtremeSorter.#ctor(System.Windows.Forms.SortOrder,System.Collections.Generic.List{System.Object})">
 <summary>
 Sortiert die angegebene(n) Spalte(n) der ListView
 </summary>
 <param name="Sortfolge">Die SortierRehenfolge (Aufsteigend oder Absteigend)</param>
 <param name="SortList">Liste mit Indexschlüssel als Integer und Alphanumerische Angaben als Integer (z.b. New List(Of Object) ({New Object() {0, 0}, New Object() {7, 0}, New Object() {8, 1}}))</param>
 <remarks></remarks>
</member>
<member name="M:PFP.ListViewItemExtremeSorter.#ctor(System.Windows.Forms.SortOrder,System.Windows.Forms.ListView@,System.Collections.Generic.List{System.Object})">
 <summary>
 Sortiert die angegebene(n) Spalte(n) der ListView
 </summary>
 <param name="Sortfolge">Die SortierRehenfolge (Aufsteigend oder Absteigend)</param>
 <param name="LV">Die ListView, aus der die ColumnIDX bezogen werden können</param>
 <param name="SortList">Liste mit Indexschlüssel als Integer und Alphanumerische Angaben als Integer (z.b. New List(Of Object)({New Object() {"Datum", 0}, New Object() {"Mitarbeiter", 0}, New Object() {"Reihenfolge", 1}}))</param>
 <remarks></remarks>
</member>
<member name="M:PFP.ListViewItemExtremeSorter.#ctor(System.Windows.Forms.SortOrder,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
 <summary>
 Sortiert die angegebene(n) Spalte(n) der ListView
 </summary>
 <param name="Sortfolge">Die SortierRehenfolge (Aufsteigend oder Absteigend)</param>
 <param name="Pri">Primärschlüssel: Index der 1. Spalte (muss vorhanden sein)</param>
 <param name="AlphaNrPri">Optionaler Parameter für Alphanummerische sortierung für Pri</param>
 <param name="Sek">Optionaler Sekundärschlüssel: Index der 2. Spalte (-1, falls nicht genutzt)</param>
 <param name="AlphaNrSek">Optionaler Parameter für Alphanummerische sortierung für Sek</param>
 <param name="Ter">Optionaler Tertiärschlüssel: Index der 3. Spalte (-1, falls nicht genutzt)</param>
 <param name="AlphaNrTer">Optionaler Parameter für Alphanummerische sortierung für Ter</param>
 <param name="Qua">Optionaler Quartärschlüssel: Index der 4. Spalte (-1, falls nicht genutzt)</param>
 <param name="AlphaNrQua">Optionaler Parameter für Alphanummerische sortierung für Qua</param>
 <param name="Qui">Optionaler Quintärschlüssel: Index der 5. Spalte (-1, falls nicht genutzt)</param>
 <param name="AlphaNrQui">Optionaler Parameter für Alphanummerische sortierung für Qui</param>
 <remarks></remarks>
</member>
<member name="M:PFP.ListViewItemExtremeSorter.Compare(System.Object,System.Object)">
 <summary>
 Vergleich von Spalten (Primär-/Sekündär-/Tertiärspalte)
 Benennungen von lateinischen Ordnungszahlen: 1=Primär, 2=Sekundär, 3=Tertiär, 4=Quartär, 5=Quintär, 6=Sextär, 7=Septimär, 8=Oktaviär, 9=Noniär, 10=Dezimär, 11=Un(o)dezimär, 12=Duodezimär, 13=Ter(Tres)dezimär
 zur Unterstützung des Sorts im ListView
 </summary>
 <param name="Element1">Element1 als ListViewItem</param>
 <param name="Element2">Element2 als ListViewItem</param>
 <returns>-1, 0 oder 1 (gemäß Vergleich)</returns>
 <remarks></remarks>
</member>
<member name="M:PFP.Elliptic.Curve25519.ClampPrivateKeyInline(System.Byte[])">
 <summary>
 Private key clamping (inline, for performance)
 </summary>
 <param name="key">[out] 32 random bytes</param>
</member>
<member name="M:PFP.Elliptic.Curve25519.ClampPrivateKey(System.Byte[])">
 <summary>
 Private key clamping
 </summary>
 <param name="rawKey">[out] 32 random bytes</param>
</member>
<member name="M:PFP.Elliptic.Curve25519.CreateRandomPrivateKey">
 <summary>
 Creates a random private key
 </summary>
 <returns>32 random bytes that are clamped to a suitable private key</returns>
</member>
<member name="M:PFP.Elliptic.Curve25519.KeyGenInline(System.Byte[],System.Byte[],System.Byte[])">
 <summary>
 Key-pair generation (inline, for performance)
 </summary>
 <param name="publicKey">[out] public key</param>
 <param name="signingKey">[out] signing key (ignored if NULL)</param>
 <param name="privateKey">[out] private key</param>
 <remarks>WARNING: if signingKey is not NULL, this function has data-dependent timing</remarks>
</member>
<member name="M:PFP.Elliptic.Curve25519.GetPublicKey(System.Byte[])">
 <summary>
 Generates the public key out of the clamped private key
 </summary>
 <param name="privateKey">private key (must use ClampPrivateKey first!)</param>
</member>
<member name="M:PFP.Elliptic.Curve25519.GetSigningKey(System.Byte[]@,System.Byte[]@,System.Byte[])">
 <summary>
 Generates signing key out of the clamped private key
 </summary>
 <param name="privateKey">private key (must use ClampPrivateKey first!)</param>
</member>
<member name="M:PFP.Elliptic.Curve25519.GetSharedSecret(System.Byte[],System.Byte[])">
 <summary>
 Key agreement
 </summary>
 <param name="privateKey">[in] your private key for key agreement</param>
 <param name="peerPublicKey">[in] peer's public key</param>
 <returns>shared secret (needs hashing before use)</returns>
</member>
<member name="M:PFP.Elliptic.Curve25519.Egcd32(System.Byte[]@,System.Byte[]@,System.Byte[]@,System.Byte[]@)">
 <summary>
 Returns x if a contains the gcd, y if b.
 </summary>
 <param name="x">x and y must have 64 bytes space for temporary use.</param>
 <param name="y">x and y must have 64 bytes space for temporary use.</param>
 <param name="a">requires that a[-1] and b[-1] are valid memory locations</param>
 <param name="b">requires that a[-1] and b[-1] are valid memory locations</param>
 <returns>Also, the returned buffer contains the inverse of a mod b as 32-byte signed.</returns>
</member>
<member name="M:PFP.Elliptic.Curve25519.IsOverflow(PFP.Elliptic.Curve25519.Long10)">
 <summary>
 Check if reduced-form input >= 2^255-19
 </summary>
</member>
<member name="M:PFP.Elliptic.Curve25519.Copy(PFP.Elliptic.Curve25519.Long10@,PFP.Elliptic.Curve25519.Long10@)">
 <summary>
 Copy a number
 </summary>
</member>
<member name="M:PFP.Elliptic.Curve25519.Set(PFP.Elliptic.Curve25519.Long10@,System.Int32@)">
 <summary>
 Set a number to value, which must be in range -185861411 .. 185861411
 </summary>
</member>
<member name="M:PFP.Elliptic.Curve25519.MulSmall(PFP.Elliptic.Curve25519.Long10@,PFP.Elliptic.Curve25519.Long10@,System.Int64@)">
 <summary>
 Multiply a number by a small integer in range -185861411 .. 185861411.
 The output is in reduced form, the input x need not be.  x and xy may point
 to the same buffer.
 </summary>
</member>
<member name="M:PFP.Elliptic.Curve25519.Multiply(PFP.Elliptic.Curve25519.Long10@,PFP.Elliptic.Curve25519.Long10@,PFP.Elliptic.Curve25519.Long10@)">
 <summary>
 Multiply two numbers. The output is in reduced form, the inputs need not be.
 </summary>
</member>
<member name="M:PFP.Elliptic.Curve25519.Square(PFP.Elliptic.Curve25519.Long10@,PFP.Elliptic.Curve25519.Long10@)">
 <summary>
 Square a number.  Optimization of  Multiply(x2, x, x)
 </summary>
</member>
<member name="M:PFP.Elliptic.Curve25519.Reciprocal(PFP.Elliptic.Curve25519.Long10@,PFP.Elliptic.Curve25519.Long10@,System.Boolean@)">
 <summary>
 Calculates a reciprocal.  The output is in reduced form, the inputs need not 
 be.  Simply calculates  y = x^(p-2)  so it's not too fast. */
 When sqrtassist is true, it instead calculates y = x^((p-5)/8)
 </summary>
</member>
<member name="M:PFP.Elliptic.Curve25519.IsNegative(PFP.Elliptic.Curve25519.Long10)">
 <summary>
 Checks if x is "negative", requires reduced input
 </summary>
 <param name="x">must be reduced input</param>
</member>
<member name="M:PFP.Elliptic.Curve25519.CurveEquationInline(PFP.Elliptic.Curve25519.Long10@,PFP.Elliptic.Curve25519.Long10@,PFP.Elliptic.Curve25519.Long10@)">
 <summary>
 Y^2 = X^3 + 486662 X^2 + X
 </summary>
 <param name="y2">output</param>
 <param name="x">X</param>
 <param name="temp">temporary</param>
</member>
<member name="M:PFP.Elliptic.Curve25519.Core(System.Byte[]@,System.Byte[]@,System.Byte[]@,System.Byte[]@)">
 <summary>
 P = kG   and  s = sign(P)/k
 </summary>
</member>
<member name="F:PFP.Elliptic.Curve25519.OrderTimes8">
 <summary>
 Smallest multiple of the order that's >= 2^255
 </summary>
</member>
<member name="F:PFP.Elliptic.Curve25519.BaseR2Y">
 <summary>
 Constant 1/(2Gy)
 </summary>
</member>
<member name="M:PFP.ModFunctions.DateIntToCandle(System.Collections.Generic.List{System.Object})">
 <summary>
 
 </summary>
 <param name="DateValueList">Liste mit Datums und dessen Werte</param>
 <returns></returns>
</member>
<member name="M:PFP.ModFunctions.EMAx(System.Collections.Generic.List{System.Object},System.Int32)">
 <summary>
 
 </summary>
 <param name="DateValueList">Liste mit Datums und dessen Werte</param>
 <param name="EMA">die EMA zahl</param>
 <returns></returns>
</member>
<member name="M:PFP.ModFunctions.MACDx(System.Collections.Generic.List{System.Object},System.Collections.Generic.List{System.Object})">
 <summary>
 
 </summary>
 <param name="EMA1">Liste des ersten EMA</param>
 <param name="EMA2">Liste des zweiten EMA</param>
 <returns></returns>
</member>
</members>
</doc>
